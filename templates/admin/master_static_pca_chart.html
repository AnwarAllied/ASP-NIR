{% load static %}
<style>
    .chart-container ul li{
        display:inline-block;
        margin-right:15px;
        background: url
    }
    .chart-container ul li::before{
        content:"- ";
        color:#447e9b;
    }
    h4{
        color:#447e9b;
    }

    .match_div{
        float: right
        
        };
    #myChart{
    margin-top:15px;
    }
    #match_go{
    background: #79aec8;
    border: none;
    border-radius: 4px;
    color: #fff;
    margin: 2px 0;
    padding: 2px 3px;
    vertical-align: middle;
    font-family: "Roboto", "Lucida Grande", Verdana, Arial, sans-serif;
    font-weight: normal;
    font-size: 13px;
    cursor:pointer;
}

</style>
<ul class="messagelist">

</ul>
<div class="chart-container">
    <h1>{{ figure_header }}</h1>
    <h4>Model includes {{ spec_num }} spectra and {{ group_num }} groups, components of PCA model is {{ components }} </h4>
    <progress id="animationProgress" max="1" value="0" style="width: 100%"></progress>
    <canvas id="myChart"></canvas>
</div>
<button onclick="toggle_label(this)" id="toggle_label">Hide Label</button>

{% if model == 'match' %}
<div class="match_div">
<span>Click to select different method for matching:</span>
    <select id="match_method">
        <option value="pca2"selected>Master PCA (default)</option>
        <option value="pca1">Master PCA scaled</option>
        <!-- <option value="poly">Poly</option> -->
        <!-- <option value="pls">Master PLS</option>-->
    </select>
    <button id="match_go" onclick="change_method(this)">Go</button>
</div>
{% endif %}

<script src="{% static 'js/jquery-1.10.0.min.js' %}"></script>
<script type="text/javascript" src="{% static 'js/Chart.min.js' %}"></script>
<script>

    var progress = document.getElementById('animationProgress');

    function start_progress() {
        step=0.1;
        this.progress.value= this.progress.value + step ;
        if (this.progress.value >1) {
            clearInterval(setProg) 
        }
    }; 
    var setProg = setInterval(start_progress, 200);

    var hide_by_color = function (e, legendItem) {
    // var hide_by_color = function (chart) {
        var index = legendItem.datasetIndex;
        let ci = this.chart;
        // var index = chart.legend.legendItems;
        var color=ci.data.datasets[index].pointBackgroundColor 
        // console.log(e)
        ci.data.datasets.forEach(function(meta) {
            if (meta.pointBackgroundColor == color) {
                meta.hidden = meta.hidden === null ? !meta.hidden : null;
            }
        });
        ci.update();
    };

    $.get('{% url "master_pca_chart" %}?id={{ obj_id }}&model={{ model }}&match_id={{ match_id }}{{ pca_tag }}', function(data) {
        clearInterval(setProg)
        color=data.color_ix
        Gdata = data
        var cv = $("#myChart").get(0)
        var ctx = cv.getContext("2d");
        chart = new Chart.Scatter(ctx, {
            type: "line",
            data:data,
            options: {
                scales: {
                    yAxes: [{
                        scaleLabel: {
                            display: true,
                            labelString: 'Second component'
                        }
                    }],
                    xAxes: [{
                        scaleLabel: {
                            display: true,
                            labelString: 'First component'
                        }
                    }]
                },
                legend: {
                    labels:{
                        usePointStyle: true,
                        filter: function(item, chart){
                            return color.includes(item.datasetIndex);
                            // return item.datasetIndex == data.datasets.length-1;
                        }
                    },
                    onClick: hide_by_color,
                    
                },
                tooltips: {
                    callbacks: {
                        label: function(tooltipItem, data) {
                            var label = data.datasets[tooltipItem.datasetIndex].label || '';

                            if (label) {
                                label += ': ';
                            }
                            label += '(' + Math.round(tooltipItem.xLabel*100)/100 + ', ' + Math.round(tooltipItem.yLabel*100)/100 + ')';
                            return label;
                        }
                    }
                },
                hover:{
                    onHover:function(e){
                        var point = this.getElementAtEvent(e);
                        if(point.length) e.target.style.cursor = 'pointer';
                        else e.target.style.cursor = 'default';
                    }
                },
                animation: {
                    duration: 100,
                    onProgress: function(animation) {
                        progress.value = (animation.currentStep / animation.numSteps)*(1-progress.value) +progress.value;
                    },
                    onComplete: function(animation) {
                        $( "progress#animationProgress" ).hide();
                    }
                }
            }
        });
        // chart.config.data.datasets[data.datasets.length-1].pointStyle='rect'
        // chart.config.data.datasets[data.datasets.length-1].pointRadius=8
        chart.update()
    });

    function toggle_label(obj) {
        chart.options.legend.display= !chart.options.legend.display;
        $("#toggle_label").text($("#toggle_label").text()==="Hide Label"?"Show Label":"Hide Label");
        chart.update();
    };
    {% if model == 'match' %}
    function change_method(){
	var method=$('#match_method').val();
	// if(method=='poly'){
	//     $.get('{% url "line_chart_json" %}?model={{ model }}&ids={{ ids }}{% if plot_mode == "detail" %}&mode=detail{% endif %}',function(data){
    //         Gdata = data;
    //         chart.data.datasets.forEach(function(dataset, index) {
    //             dataset.data = Gdata['datasets'][index]["data"];
    //             dataset.label = Gdata['datasets'][index]['label'];
    //         });
    //         chart.update();
	//     });
	// }
	// else if(method.slice(0,3)=='pca'){
        if(method.slice(0,3)=='pca'){
            $.get('{% url "spectraModelling:chart" match_id=match_id %}?id='+method.slice(-1)+'&model=match', function(data){
                Gdata = data
                chart.data.datasets.forEach(function(dataset, index) {
                    dataset.data = Gdata['datasets'][index]["data"];
                    dataset.label = Gdata['datasets'][index]['label'];
                });
                chart.update();
            });
        }
    }
    {% endif %}
</script>